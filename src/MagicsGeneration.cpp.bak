
// auto GetOccupancy(int index, std::uint64_t attack_mask) { // OK CONSTEXPR
//     std::uint64_t occupancy = 0ULL;
//     const auto mask_population = Utils::BitCount(attack_mask);
//     for (int count = 0; count < mask_population; count++) {
//         auto square = Utils::IndexLS1B(attack_mask);
//         if (attack_mask  & (1ULL << square)) // PopSquare // TODO: Make this constexpr
//             attack_mask ^= (1ULL << square);
//         if (index & (1 << count))
//             occupancy |= (1ULL << square);
//     }
//     return occupancy;
// }

// std::mt19937_64 rng64(123456);
// template <EnumPiece Piece>
// auto FindMagicNumber(std::size_t square) noexcept { // Cannot be constexpr, but can be precalculated.
//     std::array<std::uint64_t, 4096> occupancies = { };
//     std::array<std::uint64_t, 4096> attacks = { };
//     std::array<std::uint64_t, 4096> used_attacks = { };
//     auto attack_mask = Attack<Piece>::MaskTable[square]; // Ok constexpr
//     auto relevant_bits = Attack<Piece>::MaskBitCount[square]; // Ok constexpr
//     int occupancy_idx = 1 << relevant_bits;

//     for (int idx = 0; idx < occupancy_idx; idx++) {
//         occupancies[idx] = GetOccupancy(idx, attack_mask); // Ok Constexpr
//         attacks[idx] = SliderAttacks<Piece>::On(square, occupancies[idx]); // Ok constexpr
//     }

//     for (int random_count = 0; random_count < 10000000; random_count++) {
//         std::uint64_t magic = rng64() & rng64() & rng64(); // could be constexpr
//         if (Utils::BitCount((attack_mask * magic) ^ 56) < 6) continue;
//         used_attacks.fill(0x00);
//         int idx, fail;
//         for (idx = 0, fail = 0; !fail && idx < occupancy_idx; idx++ ) {
//             std::uint64_t magic_idx = (occupancies[idx] * magic) >> (64 - relevant_bits);
//             if (used_attacks[magic_idx] == 0ULL)
//                 used_attacks[magic_idx] = attacks[idx];
//             else if (used_attacks[magic_idx] != attacks[idx]) fail = 1;
//         }

//         if (!fail) return magic;
//     }
//     std::cout << "magic failed\n";
//     return std::uint64_t(0);
// }

// template <EnumPiece Piece>
// auto GenerateMagicNumbers() noexcept {
//     std::array<std::uint64_t, 64> magics { };
//     for (int square = 0; square < 64; square++) {
//         magics[square] = FindMagicNumber<Piece>(square);
//     } return magics;
// }

// template <EnumPiece Piece>
// std::array<std::uint64_t, 64> magix = GenerateMagicNumbers<Piece>();

// auto GetAttackMaskBitCount() {
//     std::array<int, 64> MasksBitCount = { };
//     for (int i = 0; i < 64; i++)
//         MasksBitCount[i] = Utils::BitCount(Attack<Rooks>::MaskTable[i]);
//     return MasksBitCount;
// }

// template <EnumPiece Piece>
// std::array<int, 64> AttackMaskBitCount = GetAttackMaskBitCount();

// [[nodiscard]] auto GenerateAttacks() noexcept {

//     std::array<std::array<std::uint64_t, 4096>, 64> attacks { };
//     for (int square = 0; square < 64; square++) {
//         auto attack_mask = Attack<Rooks>::MaskTable[square];
//         auto relevant_bits = Attack<Rooks>::MaskBitCount[square];
//         int occupancy_idx = 1 << relevant_bits;
//         for (int idx = 0; idx < occupancy_idx; idx++) {
//             auto occupancy = GetOccupancy(idx, attack_mask); // OK 100%
//             std::uint64_t magic_index = (occupancy * magix<Rooks>[square]) >> (64-relevant_bits);
//             attacks[square][magic_index] = SliderAttacks<Rooks>::On(square, occupancy);

//         }
//     } return attacks;
// }

// std::array<std::array<std::uint64_t, 4096>, 64> Attacks_ = GenerateAttacks();

// template <EnumPiece Piece>
// auto GetAttack(int square, std::uint64_t occupancy) { // OK
//     occupancy &= Attack<Rooks>::MaskTable[square];
//     occupancy *= magix<Rooks>[square];
//     occupancy >>= (64 - Attack<Rooks>::MaskBitCount[square]);
//     return Attacks_[square][occupancy];
// }
